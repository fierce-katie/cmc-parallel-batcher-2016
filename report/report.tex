\documentclass[oneside,final,14pt]{extreport}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{vmargin}
\usepackage{textcomp}
\newcommand*{\No}{\textnumero}
\setpapersize{A4}
\setmarginsrb{3cm}{2cm}{1cm}{2cm}{0pt}{0mm}{0pt}{13mm}
\usepackage{indentfirst}
\sloppy
\setcounter{page}{2}
\clubpenalty = 10000
\widowpenalty = 10000
%\setlength{\parskip}{0.3cm}

\begin{document}

\tableofcontents

\chapter*{Постановка задачи}
\addcontentsline{toc}{chapter}{Постановка задачи}

В задаче требовалось реализовать параллельную сортировку Бэтчера для структур,
представляющих точки на регулярной сетке (\texttt{Point}), вдоль одной из
координат ($x$ или $y$).

Структура \texttt{Point} имеет следующий вид:
\begin{verbatim}
    Point {
        float coord[2];
        int index;
    };
\end{verbatim}

Пусть сетка размерности $n_1 * n_2$ представляется массивом таких структур
\texttt{P[n1 * n2]}, а для инициализации координат точек используются функции
\texttt{x(i,~j)} и \texttt{y(i,~j)}.
Тогда \texttt{P[i*n2+j].coord[0] = x(i,~j)},
\texttt{P[i*n2+j].coord[1] = y(i,~j)}, \texttt{P[i*n2+j].index = i*n2+j}, где $i = \overline{0, n_1-1},
j = \overline{0,n_2-1}$.

На каждом процессоре должно обрабатываться одинаковое количество элементов.
Каждый процессор выполняет упорядочивание элементов независимо от других.
Слияние каждого отсортированного массива должно происходить в соответствии с
расписанием, задаваемым сетью сортировки Бэтчера.

После окончания работы программы на каждом процессе должно находиться одинаковое
количество элементов структуры \texttt{Point}. Каждый элемент структуры
\texttt{Point} одного процесса должен находиться левее по координате
по сравнению с элементом структуры \texttt{Point} любого другого процесса с
б\'{о}льшим рангом.

\chapter*{Метод решения}
\addcontentsline{toc}{chapter}{Метод решения}

\section*{Распределение элементов по процессам}
\addcontentsline{toc}{section}{Распределение элементов по процессам}

Одним из требований к программе является одинаковое количество элементов
на процессах. Чтобы выполнить это требование, при необходимости
исходный массив дополняется фиктивными элементами типа \texttt{Point} с
отрицательным значением индекса. Распределение фиктивных элементов происходит
при инициализации массивов на каждом из процессоров.

Наличие фиктивного эелемента на процессоре зависит от его номера (\texttt{rank}).
Количество процессоров, на которых нет фиктивных элементов, равно остатку от
деления количества элементов в исходном массиве на количество процессоров.
Если номер процессора меньше этого значения, то инициализируются все элементы
соответствующего фрагмента массива. В противном случае, последний элемент
массива считается фиктивным, и его поле \texttt{index} инициализируется
отрицательным значением. Такие элементы будут игнорирооваться при выводе
конечного результата.

Инициализация фрагмента массива реализована в функции
\texttt{init\_points} в файле \texttt{point.cpp}.

\section*{Сортировка и слияние фрагментов}
\addcontentsline{toc}{section}{Сортировка и слияние  фрагментов}

Сортировка элементов осуществляется вдоль оси $Ox$. Для локальной
сортировки используется стандартная функция \texttt{qsort}.

Сеть слияния представляет собой сеть сортировки Бэтчера для массива, имеющего
длину, равную количеству процессов. Каждый элемент массива равен своему индексу,
то есть номеру процесса.

Для построения этой сети сортировки используются две рекурсивные функции,
\texttt{sort} и \texttt{join}.

В функции \texttt{sort} массив рекурсивно разбивается на два подмассива,
которые рекурсивно сортируются и передаются в функцию \texttt{join}, которая
производит их слияние. База рекурсиик~--- массив из одного элемента,
который уже очевидным образом отсортирован.

Элементы с чётными и нечётными номерами объединяются отдельно рекурсивными
вызовами функции \texttt{join}. Если в подмассивах по одному элементу,
эти элементы соединяются компаратором. Если суммарное число элементов в
подмассивах больше двух, то после объединения чётных и нечётных элементов,
пары соседних элементов обрабатываются с помощью заключительной
группы компараторов. Массивы чётных и нечётных индексов хранятся в явном виде
и строятся при каждом рекурсивном вызове функции \texttt{join}.

Таким образом, после обработки всего массива индексов процессов имеем
массив компараторов, который определяет, какие процессы должны взаимодействовать
при слиянии отсортированных фрагментов. Каждый компаратор представляет собой
пару целых чисел~--- номеров процессов.

Компараторы обрабатываются следующим образом: два процесса с соответствующими
номерами отправляют друг другу свои отсортированные фрагменты массивов (их
длина одинакова), а затем перераспределяют элементы так, что на первом из
них содержатся элементы с меньшими значениями, а на втором~--- с большими.

После того, как вся сеть компараторов будет обработана, на процессорах
будут находится фрагменты упорядоченного массива, причём будет выполнено
свойство: $a_{ir} \leq a_{jr}$ при $i < j$, и $a_{kp} \leq a_{lt}$, при
$p < t$ и любых допустимых значениях $k, l$, где $i, j, k, l$~--- номера
элементов в массиве на процессе, а $r, p, t$~--- номера процессов.

\section*{Структура программы}
\addcontentsline{toc}{section}{Структура программы}

Исходный код расположен в следующих файлах:
\begin{itemize}
    \item \texttt{bsort.cpp}~--- основной файл реализации параллельной сортировки:
        построение сети слияния, инициализация и сортировка фрагментов, обмен
        отсортированными фрагментами и их слияние;
    \item \texttt{qsort.cpp}~--- последовательная сортировка;
    \item \texttt{point.[h|cpp]}~--- описание структуры \texttt{Point} и
        вспомогательные функции для работы с ней;
    \item \texttt{tools.[h|cpp]}~--- вспомогательные функции для проверки аргументов,
        печати результатов и т.\,д;
    \item \texttt{Makefile}~--- файл для сборки исполняемых файлов \texttt{bsort}
        и \texttt{qsort} (команды \texttt{make} и \texttt{make qsort}).
\end{itemize}

\chapter*{Используемая вычислительная система}
\addcontentsline{toc}{chapter}{Используемая вычислительная система}

Вычисления проводились на системе IBM Blue Gene/P.
Характеристики системы представлены на сайте \verb|http://hpc.cmc.msu.ru/bgp|.

Система состоит из двух стоек, включающих 8192 процессорных ядер
(2*1024 четырехъядерных вычислительных узлов), с пиковой производительностью
27,9 терафлопс (27,8528 триллионов операций с плавающей точкой в секунду).

Характеристики вычислительного узла:

\begin{itemize}
    \item четыре микропроцессорных ядра;
    \item пиковая производительность: 13,6 GFlop/sec;
    \item пропускная способность памяти: 13,6 GB/sec;
    \item 2 ГБ общей памяти;
    \item 2 x 4 МБ кэш-памяти 2-го уровня;
    \item легковесное ядро, представляющее собой Linux-подобную операционную систему,
        поддерживающую значительное подмножество Linux-совместимых системных вызовов;
    \item асинхронные операции межпроцессорных обменов (выполняются параллельно с вычислениями);
    \item операции ввода-вывода перенаправляются I/O-картам через сеть коллективных операций.
\end{itemize}

Все MPI-операции типа «точка-точка» осуществляются через сеть трехмерного тора.
Вычислительный узел имеет двунаправленные связи с шестью соседями.
Пропускная способность каждого соединения — 425 MB/s (5,1 GB/s для всех 12
каналов).

\chapter*{Анализ полученных результатов}
\addcontentsline{toc}{chapter}{Анализ полученных результатов}

\end{document}


