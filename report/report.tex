\documentclass[oneside,final,14pt]{extreport}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{vmargin}
\usepackage{textcomp}
\newcommand*{\No}{\textnumero}
\setpapersize{A4}
\setmarginsrb{3cm}{2cm}{1cm}{2cm}{0pt}{0mm}{0pt}{13mm}
\usepackage{indentfirst}
\sloppy
\setcounter{page}{2}
\clubpenalty = 10000
\widowpenalty = 10000
\setlength{\parskip}{0.3cm}

\begin{document}

\tableofcontents

\chapter*{Постановка задачи}
\addcontentsline{toc}{chapter}{Постановка задачи}

В задаче требовалось реализовать параллельную сортировку Бэтчера для структур,
представляющих точки на регулярной сетке (\texttt{Point}), вдоль одной из
координат ($x$ или $y$).

Структура \texttt{Point} имеет следующий вид:
\begin{verbatim}
    Point {
        float coord[2];
        int index;
    };
\end{verbatim}

Пусть сетка размерности $n_1 * n_2$ представляется массивом таких структур
\texttt{P[n1 * n2]}, а для инициализации координат точек используются функции
\texttt{float x(int i, int j)} и \texttt{float y(int i, int j)}.
Тогда \texttt{P[i*n2+j].coord[0] = x(i, j)},
\texttt{P[i*n2+j].coord[1] = y(i,j)}, \texttt{P[i*n2+j].index = i*n2+j}, где $i = \overline{0, n_1-1},
j = \overline{0,n_2-1}$.

На каждом процессоре должно обрабатываться одинаковое количество элементов.
Каждый процессор выполняет упорядочивание элементов независимо от других.
Слияние каждого отсортированного массива должно происходить в соответствии с
расписанием, задаваемым сетью сортировки Бэтчера.

После окончания работы программы на каждом процессе должно находиться одинаковое
количество элементов структуры \texttt{Point}. Каждый элемент структуры
\texttt{Point} одного процесса должен находиться левее по координате
по сравнению с элементом структуры \texttt{Point} любого другого процесса с
б\'{о}льшим рангом.

Программа должна демонстрировать эффективность не менее 80\% от максимально
возможной на числе вычислительных ядер не менее 128.

\chapter*{Метод решения}
\addcontentsline{toc}{chapter}{Метод решения}

\section*{Распределение элементов по процессам}
\addcontentsline{toc}{section}{Распределение элементов по процессам}

Одним из требований к программе является одинаковое количество элементов
на процессах. Чтобы выполнить это требование, при необходимости
исходный массив дополняется фиктивными элементами типа \texttt{Point} с
отрицательным значением индекса. Распределение фиктивных элементов происходит
при инициализации массивов на каждом из процессоров.

Наличие фиктивного эелемента на процессоре зависит от его номера (\texttt{rank}).
Количество процессоров, на которых нет фиктивных элементов, равно остатку от
деления количества элементов в исходном массиве на количество процессоров.
Если номер процессора меньше этого значения, то инициализируются все элементы
соответствующего фрагмента массива. В противном случае, последний элемент
массива считается фиктивным, и его поле \texttt{index} инициализируется
отрицательным значением. Такие элементы будут игнорирооваться при выводе
конечного результата.

Инициализация фрагмента массива реализована в функции
\texttt{init\_points} в файле \texttt{point.cpp}.

\section*{Сортировка элементов}
\addcontentsline{toc}{section}{Сортировка элементов}

Для сортировки фрагментов массива на каждом процессе используется
оптимизированный нерекурсивный алгоритм сортировки слиянием.

Массив разбивается на ещё меньшие фрагменты, к каждому из
которых применяется алгоритм пирамидальной сортировки.

\section*{Слияние отсортированных фрагментов}
\addcontentsline{toc}{section}{Слияние отсортированных фрагментов}

Сеть слияния представляет собой сеть сортировки Бэтчера для массива, имеющего
длину, равную количеству процессов. Каждый элемент массива равен своему индексу,
то есть номеру процесса.

Для построения этой сети сортировки используются две рекурсивные функции,
\texttt{sort} и \texttt{join}.

В функции \texttt{sort} массив рекурсивно разбивается на два подмассива,
которые рекурсивно сортируются и передаются в функцию \texttt{join}, которая
производит их слияние. База рекурсиик~--- массив из одного элемента,
который уже очевидным образом отсортирован.

Элементы с чётными и нечётными номерами объединяются отдельно рекурсивными
вызовами функции \texttt{join}. Если в подмассивах по одному элементу,
эти элементы соединяются компаратором. Если суммарное число элементов в
подмассивах больше двух, то после объединения чётных и нечётных элементов,
пары соседних элементов обрабатываются с помощью заключительной
группы компараторов. Массивы чётных и нечётных индексов хранятся в явном виде
и строятся при каждом рекурсивном вызове функции \texttt{join}.

Таким образом, после обработки всего массива индексов процессов имеем
массив компараторов, который определяет, какие процессы должны взаимодействовать
при слиянии отсортированных фрагментов. Каждый компаратор представляет собой
пару целых чисел~--- номеров процессов.

Компараторы обрабатываются следующим образом: два процесса с соответствующими
номерами отправляют друг другу свои отсортированные фрагменты массивов (их
длина одинакова), а затем перераспределяют элементы так, что на первом из
них содержатся элементы с меньшими значениями, а на втором~--- с большими.

После того, как вся сеть компараторов будет обработана, на процессорах
будут находится фрагменты упорядоченного массива, причём будет выполнено
свойство: $a_{ir} \leq a_{jr}$ при $i < j$, и $a_{kp} \leq a_{lt}$, при
$p < t$ и любых допустимых значениях $k, l$, где $i, j, k, l$~--- номера
элементов в массиве на процессе, а $r, p, t$~--- номера процессов.

\section*{Структура программы}
\addcontentsline{toc}{section}{Структура программы}

\chapter*{Используемая вычислительная система}
\addcontentsline{toc}{chapter}{Используемая вычислительная система}

\chapter*{Анализ полученных результатов}
\addcontentsline{toc}{chapter}{Анализ полученных результатов}

\end{document}


