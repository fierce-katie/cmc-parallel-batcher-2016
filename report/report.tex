\documentclass[oneside,final,14pt]{extreport}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{vmargin}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{diagbox}
\newcommand*{\No}{\textnumero}
\setpapersize{A4}
\setmarginsrb{3cm}{2cm}{1cm}{2cm}{0pt}{0mm}{0pt}{13mm}
\usepackage{indentfirst}
\sloppy
\clubpenalty = 10000
\widowpenalty = 10000

\begin{document}
\vspace{0.4cm}
\begin{large}
\noindent
\textit{Галкина Екатерина Владимировна\\
Группа 524\\
2016 год}
\end{large}

\vspace{0.4cm}

{\let\clearpage\relax \chapter*{Постановка задачи}}

В задаче требовалось реализовать параллельную сортировку Бэтчера для структур,
представляющих точки на регулярной сетке (\texttt{Point}), вдоль одной из
координат ($x$ или $y$).

Структура \texttt{Point} имеет следующий вид:
\begin{verbatim}
    Point {
        float coord[2];
        int index;
    };
\end{verbatim}

Пусть сетка размерности $n_1 * n_2$ представляется массивом таких структур
\texttt{P[n1 * n2]}, а для инициализации координат точек используются функции
\texttt{x(i,~j)} и \texttt{y(i,~j)}.
Тогда \texttt{P[i*n2+j].coord[0] = x(i,~j)},
\texttt{P[i*n2+j].coord[1] = y(i,~j)}, \texttt{P[i*n2+j].index = i*n2+j}, где $i = \overline{0, n_1-1},
j = \overline{0,n_2-1}$.

На каждом процессе должно обрабатываться одинаковое количество элементов.
Каждый процесс выполняет упорядочивание элементов независимо от других.
Слияние каждого отсортированного массива должно происходить в соответствии с
расписанием, задаваемым сетью сортировки Бэтчера.

После окончания работы программы на каждом процессе должно находиться одинаковое
количество элементов структуры \texttt{Point}. Каждый элемент структуры
\texttt{Point} одного процесса должен находиться левее по координате
по сравнению с элементом структуры \texttt{Point} любого другого процесса с
б\'{о}льшим рангом.

\chapter*{Метод решения}

\section*{Распределение элементов по процессам}

Одним из требований к программе является одинаковое количество элементов
на процессах. Чтобы выполнить это требование, при необходимости
исходный массив дополняется фиктивными элементами типа \texttt{Point} с
отрицательным значением индекса. Распределение фиктивных элементов происходит
при инициализации массивов на каждом из процессов.

Наличие фиктивного элемента на процессе зависит от его номера (\texttt{rank}).
Количество процессов, на которых нет фиктивных элементов, равно остатку от
деления количества элементов в исходном массиве на количество процессов.
Если номер процесса меньше этого значения, то инициализируются все элементы
соответствующего фрагмента массива. В противном случае, последний элемент
массива считается фиктивным, и его поле \texttt{index} инициализируется
отрицательным значением. Такие элементы будут игнорироваться при выводе
конечного результата.

Инициализация фрагмента массива реализована в функции
\texttt{init\_points} в файле \texttt{point.cpp}.

\section*{Сортировка и слияние фрагментов}

Сортировка элементов осуществляется вдоль оси $Ox$. Для локальной
сортировки используется стандартная функция \texttt{qsort}.

Сеть слияния представляет собой сеть сортировки Бэтчера для массива, имеющего
длину, равную количеству процессов. Каждый элемент массива равен своему индексу,
то есть номеру процесса.

Для построения этой сети сортировки используются две рекурсивные функции,
\texttt{sort} и \texttt{join}.

В функции \texttt{sort} массив рекурсивно разбивается на два подмассива,
которые рекурсивно сортируются и передаются в функцию \texttt{join}, которая
производит их слияние. База рекурсии~--- массив из одного элемента,
который уже очевидным образом отсортирован.

Элементы с чётными и нечётными номерами объединяются отдельно рекурсивными
вызовами функции \texttt{join}. Если в подмассивах по одному элементу,
эти элементы соединяются компаратором. Если суммарное число элементов в
подмассивах больше двух, то после объединения чётных и нечётных элементов,
пары соседних элементов обрабатываются с помощью заключительной
группы компараторов. Массивы чётных и нечётных индексов хранятся в явном виде
и строятся при каждом рекурсивном вызове функции \texttt{join}.

Таким образом, после обработки всего массива индексов процессов имеем
массив компараторов, который определяет, какие процессы должны взаимодействовать
при слиянии отсортированных фрагментов. Каждый компаратор представляет собой
пару целых чисел~--- номеров процессов.

Компараторы обрабатываются следующим образом: два процесса с соответствующими
номерами отправляют друг другу свои отсортированные фрагменты массивов (их
длина одинакова), а затем перераспределяют элементы так, что на первом из
них содержатся элементы с меньшими значениями, а на втором~--- с большими.

После того, как вся сеть компараторов будет обработана, на процессах
будут находится фрагменты упорядоченного массива, причём будет выполнено
свойство: $a_{ir} \leq a_{jr}$ при $i < j$, и $a_{kp} \leq a_{lt}$, при
$p < t$ и любых допустимых значениях $k, l$, где $i, j, k, l$~--- номера
элементов в массиве на процессе, а $r, p, t$~--- номера процессов.

\section*{Структура программы}

Исходный код расположен в следующих файлах:
\begin{itemize}
    \item \texttt{bsort.cpp}~--- основной файл реализации параллельной сортировки:
        построение сети слияния, инициализация и сортировка фрагментов, обмен
        отсортированными фрагментами и их слияние;
    \item \texttt{point.[h|cpp]}~--- описание структуры \texttt{Point} и
        вспомогательные функции для работы с ней;
    \item \texttt{tools.[h|cpp]}~--- вспомогательные функции для проверки аргументов,
        печати результатов и т.\,д;
    \item \texttt{Makefile}~--- файл для сборки исполняемого файла.
\end{itemize}

\chapter*{Используемая вычислительная система}

Вычисления проводились на системе IBM Blue Gene/P.
Характеристики системы представлены на сайте \verb|http://hpc.cmc.msu.ru/bgp|.

Система состоит из двух стоек, включающих 8192 процессорных ядер
(2*1024 четырехъядерных вычислительных узлов), с пиковой производительностью
27,9 терафлопс (27,8528 триллионов операций с плавающей точкой в секунду).

Характеристики вычислительного узла:

\begin{itemize}
    \item четыре микропроцессорных ядра;
    \item пиковая производительность: 13,6 GFlop/sec;
    \item пропускная способность памяти: 13,6 GB/sec;
    \item 2 ГБ общей памяти;
    \item 2 x 4 МБ кэш-памяти 2-го уровня;
    \item легковесное ядро, представляющее собой Linux-подобную операционную систему,
        поддерживающую значительное подмножество Linux-совместимых системных вызовов;
    \item асинхронные операции межпроцессорных обменов (выполняются параллельно с вычислениями);
    \item операции ввода-вывода перенаправляются I/O-картам через сеть коллективных операций.
\end{itemize}

Все MPI-операции типа «точка-точка» осуществляются через сеть трехмерного тора.
Вычислительный узел имеет двунаправленные связи с шестью соседями.
Пропускная способность каждого соединения — 425 MB/s (5,1 GB/s для всех 12
каналов). Латентность (ближайший сосед): 32-байтный пакет~--- 0,1 $\mu$s
256-байтный пакет~--- 0,8 $\mu$s.

\chapter*{Анализ полученных результатов}

\section*{Результаты}

Ниже приведены таблицы и графики зависимости времени работы (рис.~\ref{time_fig},
таб.~\ref{time_tab})
и эффективности распараллеливания (рис.~\ref{eff_fig}, таб.~\ref{eff_tab})
от числа процессов для сеток размером $1000*1000$,
$2500*2500$, $4000*4000$ и $10000*10000$ элементов (в последнем случае
эффективность не подсчитана, т.\,к. для работы последовательной программы
не хватает памяти).

В таблице \ref{tacts} показано число тактов сортировки Бэтчера.

Эффективность рассчитывалась по формуле: $\frac{T(1)}{T(n)*n}$,
где $T(n)$~--- время работы программы на $n$ процессах.

\section*{Вывод}

На тестовых сетках предложенная реализация параллельной сортировки Бэтчера
показывает хорошую степень эффективности. Хотя с увеличением числа процессов
эффективность снижается, среднее значение на тестовых данных приблизительно
равно 87\% на 128 процессах и 82\% на 256 процессах.

\begin{table}[hp]
\centering
\begin{tabular}{|r|r|}\hline
    Процессы & Такты    \\ \hline
    1      &  0 \\ \hline
    2      &  1 \\ \hline
    4      &  3 \\ \hline
    8      &  6 \\ \hline
    16     &  10\\ \hline
    32     &  15\\ \hline
    64     &  21\\ \hline
    128    &  28\\ \hline
    256    &  36\\ \hline
\end{tabular}
\caption{Число тактов сортировки Бэтчера}
\label{tacts}
\end{table}

\begin{table}[hp]
\centering
\begin{tabular}{|r|r|r|r|r|}\hline
\backslashbox{Процессы}{Сетка}
           & 1000*1000 & 2500*2500 & 4000*4000 & 10000*10000 \\ \hline
    1      & 3.166644  & 22.663123 & 61.024395 & -           \\ \hline
    2      & 1.62113   & 11.591094 & 31.20125  & 159.163933  \\ \hline
    4      & 0.81447   & 5.816012  & 15.652921 & 109.449973  \\ \hline
    8      & 0.414321  & 2.906843  & 7.85178   & 54.894803   \\ \hline
    16     & 0.210412  & 1.452879  & 3.968194  & 27.525096   \\ \hline
    32     & 0.110953  & 0.740488  & 1.997691  & 13.898283   \\ \hline
    64     & 0.059545  & 0.375994  & 0.998189  & 6.975275    \\ \hline
    128    & 0.03234   & 0.19238   & 0.508733  & 3.464196    \\ \hline
    256    & 0.017605  & 0.102629  & 0.26092   & 1.745881    \\ \hline
\end{tabular}
\caption{Время работы, сек.}
\label{time_tab}
\end{table}

\begin{table}[hp]
\centering
\begin{tabular}{|r|r|r|r|}\hline
\backslashbox{Процессы}{Сетка}
           & 1000*1000 & 2500*2500 & 4000*4000 \\ \hline
    2      & 0.976678  & 0.977609  & 0.977916  \\ \hline
    4      & 0.971953  & 0.974169  & 0.974648  \\ \hline
    8      & 0.955372  & 0.974559  & 0.971506  \\ \hline
    16     & 0.940608  & 0.974923  & 0.961149  \\ \hline
    32     & 0.891888  & 0.956426  & 0.954608  \\ \hline
    64     & 0.830948  & 0.9418    & 0.955236  \\ \hline
    128    & 0.764979  & 0.920343  & 0.937138  \\ \hline
    256    & 0.702624  & 0.862600  & 0.913600  \\ \hline
\end{tabular}
\caption{Эффективность распараллеливания}
\label{eff_tab}
\end{table}

\begin{figure}[hp]
    \centering
    \includegraphics[width=0.9\textwidth]{time_chart}
    \caption{График зависимости времени работы программы от числа процессов}
    \label{time_fig}
\end{figure}

\begin{figure}[hp]
    \centering
    \includegraphics[width=0.9\textwidth]{eff_chart}
    \caption{График зависимости эффективности распараллеливания от числа процессов}
    \label{eff_fig}
\end{figure}

\end{document}


