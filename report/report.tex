\documentclass[oneside,final,14pt]{extreport}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{vmargin}
\usepackage{textcomp}
\newcommand*{\No}{\textnumero}
\setpapersize{A4}
\setmarginsrb{3cm}{2cm}{1cm}{2cm}{0pt}{0mm}{0pt}{13mm}
\usepackage{indentfirst}
\sloppy
\setcounter{page}{2}
\clubpenalty = 10000
\widowpenalty = 10000
\setlength{\parskip}{0.3cm}

\begin{document}

\tableofcontents

\chapter*{Постановка задачи}
\addcontentsline{toc}{chapter}{Постановка задачи}

В задаче требовалось реализовать параллельную сортировку Бэтчера для структур,
представляющих точки на регулярной сетке (\texttt{Point}), вдоль одной из
координат ($x$ или $y$).

Структура \texttt{Point} имеет следующий вид:
\begin{verbatim}
    Point {
        float coord[2];
        int index;
    };
\end{verbatim}

Пусть сетка размерности $n_1 * n_2$ представляется массивом таких структур
\texttt{P[n1 * n2]}, а для инициализации координат точек используются функции
\texttt{float x(int i, int j)} и \texttt{float y(int i, int j)}.
Тогда \texttt{P[i*n2+j].coord[0] = x(i, j)},
\texttt{P[i*n2+j].coord[1] = y(i,j)}, \texttt{P[i*n2+j].index = i*n2+j}, где $i = \overline{0, n_1-1},
j = \overline{0,n_2-1}$.

На каждом процессоре должно обрабатываться одинаковое количество элементов.
Каждый процессор выполняет упорядочивание элементов независимо от других.
Слияние каждого отсортированного массива должно происходить в соответствии с
расписанием, задаваемым сетью сортировки Бэтчера.

После окончания работы программы на каждом процессе должно находиться одинаковое
количество элементов структуры \texttt{Point}. Каждый элемент структуры
\texttt{Point} одного процесса должен находиться левее по координате
по сравнению с элементом структуры \texttt{Point} любого другого процесса с
б\'{о}льшим рангом.

Программа должна демонстрировать эффективность не менее 80\% от максимально
возможной на числе вычислительных ядер не менее 128.

\chapter*{Метод решения}
\addcontentsline{toc}{chapter}{Метод решения}

\section*{Построение сети слияния}
\addcontentsline{toc}{section}{Построение сети слияния}

Сеть слияния представляет собой сеть сортировки Бэтчера для массива, имеющего
длину, равную количеству процессов. Каждый элемент массива равен своему индексу,
то есть номеру процесса.

Для построения этой сети сортировки используются две рекурсивные функции,
\texttt{sort} и \texttt{join}.

В функции \texttt{sort} массив рекурсивно разбивается на два подмассива,
которые рекурсивно сортируются и передаются в функцию \texttt{join}, которая
производит их слияние. База рекурсиик~--- массив из одного элемента,
который уже очевидным образом отсортирован.

Элементы с чётными и нечётными номерами объединяются отдельно рекурсивными
вызовами функции \texttt{join}. Если в подмассивах по одному элементу,
эти элементы соединяются компаратором. Если суммарное число элементов в
подмассивах больше двух, то после объединения чётных и нечётных элементов,
пары соседних элементов обрабатываются с помощью заключительной
группы компараторов. Массивы чётных и нечётных индексов хранятся в явном виде
и строятся при каждом рекурсивном вызове функции \texttt{join}.

Таким образом, после обработки всего массива индексов процессов имеем
массив компараторов, который определяет, какие процессы должны взаимодействовать
при слиянии отсортированных фрагментов. Каждый компаратор представляет собой
пару целых чисел~--- номеров процессов.

\section*{Распределение элементов по процессам}
\addcontentsline{toc}{section}{Распределение элементов по процессам}

Одним из требований к программе является одинаковое количество элементов
на процессах. Чтобы выполнить это требование, при необходимости
исходный массив дополняется фиктивными элементами типа \texttt{Point} с
отрицательным значением индекса. Они записываются в конец исходного массива.

Если распределять элементы по процессам последовательно, то фрагмент
массива на последнем процессе может целиком состоять из фиктивных элементов.
Такое произойдёт, если количество фиктивных элементов равно количеству
элементов на каждом процессе: например, при $n = 6, p = 4$, необходимо
добавить 2 фиктивных элемента, и они оба будут находиться на последнем
процессе.

Чтобы избежать этого, каждый процесс формирует свой фрагмент массива следующим
образом: на процессе с номером $rank$ обрабатываются элементы с номерами
$rank, rank + p, rank + 2*p ...$, где $p$~--- количество процессов. В итоге на
каждом процессе обрабатывается максимум один фиктивный элемент.

\section*{Сортировка элементов}
\addcontentsline{toc}{section}{Сортировка элементов}

\section*{Слияние отсортированных фрагментов}
\addcontentsline{toc}{section}{Слияние отсортированных фрагментов}

\chapter*{Используемая вычислительная система}
\addcontentsline{toc}{chapter}{Используемая вычислительная система}

\chapter*{Анализ полученных результатов}
\addcontentsline{toc}{chapter}{Анализ полученных результатов}

\end{document}


